<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>It's Noted üß†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    :root {
        --bg: #f7f4f0;
        --card: #ffffff;
        --text: #4a4a4a;
        --text-light: #8a8a8a;
        --border: #e8e4df;
        --primary: #9b8b7e;
        --primary-hover: #8a7a6d;
        --accent: #c9b8a8;
        --success: #a8c9a8;
        --shadow: rgba(0, 0, 0, 0.08);
        --radius: 16px;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
        padding: 0;
        min-height: 100vh;
        overflow-x: hidden; /* MOBILE SAFETY: Prevent horizontal scroll */
    }

    .container {
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        padding-bottom: 100px;
    }

    header {
        text-align: center;
        padding: 30px 0 20px;
    }

    h1 {
        font-size: 28px;
        font-weight: 600;
        color: var(--primary);
        margin-bottom: 8px;
    }

    .tagline {
        color: var(--text-light);
        font-size: 15px;
        font-style: italic;
    }

    .card {
        background: var(--card);
        border-radius: var(--radius);
        padding: 24px;
        margin-bottom: 16px;
        box-shadow: 0 2px 8px var(--shadow);
        width: 100%;
        max-width: 100%; /* MOBILE SAFETY: Prevent card overflow */
    }

    .button {
        background: var(--primary);
        color: white;
        border: none;
        border-radius: 12px;
        padding: 16px 24px;
        font-size: 16px;
        font-weight: 500;
        width: 100%;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 12px;
    }

    .button:hover {
        background: var(--primary-hover);
        transform: translateY(-1px);
    }

    .button:active {
        transform: translateY(0);
    }

    .button.secondary {
        background: var(--bg);
        color: var(--text);
    }

    .button.secondary:hover {
        background: var(--border);
    }

    .button.small {
        padding: 10px 16px;
        font-size: 14px;
    }

    .preset-category {
        margin-bottom: 12px;
    }

    .category-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: var(--bg);
        border-radius: 10px;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
    }

    .category-header:hover {
        background: var(--border);
    }

    .category-title {
        font-size: 16px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .category-icon {
        font-size: 20px;
    }

    .category-toggle {
        color: var(--text-light);
        font-size: 20px;
        transition: transform 0.2s;
    }

    .category-toggle.open {
        transform: rotate(180deg);
    }

    .presets {
        display: none;
        padding: 12px 0 0 0;
        gap: 8px;
    }

    .presets.open {
        display: flex;
        flex-direction: column;
    }

    .preset-button {
        background: white;
        border: 2px solid var(--border);
        border-radius: 10px;
        padding: 14px 16px;
        text-align: left;
        font-size: 15px;
        color: var(--text);
        cursor: pointer;
        transition: all 0.2s;
    }

    .preset-button:hover {
        border-color: var(--primary);
        background: var(--bg);
    }

    .preset-button:active {
        transform: scale(0.98);
    }

    .close-button {
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--card);
        border: 2px solid var(--border);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 2px 8px var(--shadow);
        z-index: 100;
    }

    .close-button:hover {
        background: var(--border);
    }

    .toast {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: var(--success);
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 4px 12px var(--shadow);
        opacity: 0;
        transition: all 0.3s;
        z-index: 1000;
        font-weight: 500;
    }

    .toast.show {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }

    .hidden {
        display: none !important;
    }

    .flow-screen {
        animation: slideIn 0.3s;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .flow-header {
        font-size: 20px;
        font-weight: 500;
        margin-bottom: 20px;
        color: var(--primary);
    }

    .flow-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .option-button {
        background: white;
        border: 2px solid var(--border);
        border-radius: 10px;
        padding: 16px;
        text-align: left;
        font-size: 15px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .option-button:hover {
        border-color: var(--primary);
        background: var(--bg);
    }

    .option-button.selected {
        border-color: var(--primary);
        background: var(--accent);
        color: white;
    }

    .flow-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
    }

    .slider-container {
        padding: 20px 0;
    }

    .slider {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: var(--border);
        outline: none;
        -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
    }

    .slider::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        border: none;
    }

    .nav-buttons {
        display: flex;
        gap: 12px;
    }

    .back-button {
        background: var(--bg);
        color: var(--text);
        flex: 0 0 auto;
        width: auto;
        padding: 16px 20px;
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999;
        padding: 20px;
    }

    .modal {
        background: var(--card);
        border-radius: var(--radius);
        padding: 24px;
        max-width: 400px;
        width: 100%;
        box-shadow: 0 8px 24px var(--shadow);
    }

    .modal h3 {
        margin-bottom: 16px;
        color: var(--primary);
    }

    .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 20px;
    }

    .data-view-selector {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        overflow-x: auto;
        padding-bottom: 8px;
        -webkit-overflow-scrolling: touch;
    }

    .view-tab {
        background: var(--bg);
        border: 2px solid var(--border);
        border-radius: 10px;
        padding: 10px 16px;
        font-size: 14px;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.2s;
        flex-shrink: 0;
    }

    .view-tab.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }

    .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        margin-bottom: 20px;
    }

    .stat-card {
        background: var(--bg);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
    }

    .stat-number {
        font-size: 32px;
        font-weight: 600;
        color: var(--primary);
    }

    .stat-label {
        font-size: 13px;
        color: var(--text-light);
        margin-top: 4px;
    }

    .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        margin-top: 20px;
    }

    .calendar-day {
        aspect-ratio: 1;
        background: var(--bg);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        position: relative;
    }

    .calendar-day.has-logs {
        background: var(--accent);
        color: white;
    }

    .day-dots {
        display: flex;
        gap: 2px;
        margin-top: 4px;
    }

    .day-dot {
        width: 4px;
        height: 4px;
        border-radius: 50%;
        background: var(--primary);
    }

    .settings-section {
        margin-bottom: 20px;
    }

    .settings-section h3 {
        font-size: 16px;
        color: var(--primary);
        margin-bottom: 8px;
    }

    .settings-section p {
        font-size: 13px;
        line-height: 1.4;
        margin-bottom: 8px;
    }

    .person-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .person-item {
        background: var(--bg);
        border-radius: 8px;
        padding: 10px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
    }

    .delete-button {
        background: #d89b9b;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 4px 10px;
        font-size: 12px;
        cursor: pointer;
    }

    .input-group {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
    }

    /* CRITICAL FIX: Prevent flex items from overflowing on mobile */
    .input-group > * {
        min-width: 0;
    }

    /* Make Add buttons compact */
    .input-group .button {
        flex: 0 0 60px;
        padding: 10px 8px;
        font-size: 14px;
        margin-bottom: 0;
    }

    input[type="text"] {
        flex: 1;
        padding: 10px 12px;
        border: 2px solid var(--border);
        border-radius: 10px;
        font-size: 14px;
        background: white;
        max-width: 100%; /* MOBILE SAFETY: Prevent input overflow */
    }

    input[type="text"]:focus {
        outline: none;
        border-color: var(--primary);
    }

    select {
        padding: 10px 12px;
        border: 2px solid var(--border);
        border-radius: 10px;
        font-size: 14px;
        background: white;
        cursor: pointer;
        max-width: 100%; /* MOBILE SAFETY: Prevent select overflow */
    }

    select:focus {
        outline: none;
        border-color: var(--primary);
    }

    .multi-select-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 20px 0;
    }

    .multi-option {
        background: white;
        border: 2px solid var(--border);
        border-radius: 10px;
        padding: 14px;
        text-align: center;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .multi-option.selected {
        border-color: var(--primary);
        background: var(--accent);
        color: white;
    }

    .pattern-item {
        background: var(--bg);
        border-radius: 10px;
        padding: 16px;
        margin-bottom: 12px;
    }

    .pattern-item[data-insight-index] {
        cursor: pointer;
    }

    .pattern-item[data-insight-index]:hover {
        background: var(--border);
        transform: translateY(-1px);
    }

    .pattern-title {
        font-weight: 500;
        margin-bottom: 8px;
        color: var(--primary);
    }

    .insight-emoji {
        font-size: 16px;
        display: inline-block;
        vertical-align: middle;
        line-height: 1;
    }

    .pattern-detail {
        font-size: 14px;
        color: var(--text-light);
    }

    .export-section {
        margin-top: 24px;
    }
</style>
```

</head>
<body>
    <div class="container">
        <!-- Home Screen -->
        <div id="homeScreen" style="display: block;">
            <header>
                <h1>It's Noted üß†</h1>
                <p class="tagline">You don't have to explain. Nothing here is good or bad.</p>
            </header>

```
        <div class="card">
            <button class="button" id="quickLogBtn">Quick Log</button>
            <button class="button" id="manualLogBtn">Manual Log</button>
            <button class="button" id="myDataBtn">My Data</button>
            <button class="button secondary" id="settingsBtn">Settings</button>
        </div>
    </div>

    <!-- Quick Log Screen -->
    <div id="quickLogScreen" class="hidden">
        <div class="close-button" id="closeQuickLogBtn">‚úï</div>
        
        <div class="card">
            <h2 style="margin-bottom: 20px;">Quick Log</h2>
            <div id="quickLogCategories"></div>
        </div>
    </div>

    <!-- Manual Log Screen -->
    <div id="manualLogScreen" class="hidden">
        <div class="close-button" id="closeManualLogBtn">‚úï</div>
        <div class="card">
            <h2 style="margin-bottom: 20px;">Manual Log</h2>
            <div id="manualLogFlow"></div>
        </div>
    </div>

    <!-- My Data Screen -->
    <div id="myDataScreen" class="hidden">
        <div class="close-button" id="closeMyDataBtn">‚úï</div>
        <div class="card">
            <h2 style="margin-bottom: 20px;">My Data</h2>
            <div class="data-view-selector">
                <div class="view-tab active" data-view="insights">Insights</div>
                <div class="view-tab" data-view="overview">Connections</div>
                <div class="view-tab" data-view="calendar">Calendar</div>
                <div class="view-tab" data-view="patterns">Similar Days</div>
            </div>
            <div id="dataViewContent"></div>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settingsScreen" class="hidden">
        <div class="close-button" id="closeSettingsBtn">‚úï</div>
        <div class="card">
            <h2 style="margin-bottom: 20px;">Settings</h2>
            <div id="settingsContent"></div>
        </div>
    </div>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast"></div>

<!-- Modal Container -->
<div id="modalContainer"></div>

<script>
    // Global app state
    const App = {
        manualLogState: {
            category: null,
            data: {}
        }
    };

    // Data structure
    const DEFAULT_PRESETS = {
        sleep: {
            icon: 'üí§',
            name: 'Sleep',
            presets: [
                "Can't sleep ‚Äì racing thoughts",
                "Can't sleep ‚Äì bad thoughts",
                "Can't sleep ‚Äì not tired",
                "Slept but not rested",
                "Bad sleep streak"
            ]
        },
        work: {
            icon: 'üè¢',
            name: 'Work',
            presets: [
                "Coworker interaction",
                "Work overwhelm",
                "Work anticipation",
                "Drained after work",
                "Work spiral"
            ]
        },
        internal: {
            icon: 'üß†',
            name: 'Internal',
            presets: [
                "Overstimulated",
                "Burnt out",
                "Numb / disconnected",
                "Heavy / low",
                "Anxious spiral",
                "Brain loud"
            ]
        },
        social: {
            icon: 'üë•',
            name: 'Social',
            presets: [
                "Socially drained",
                "Feeling excluded",
                "Conflict aftermath",
                "Good social time"
            ]
        },
        positive: {
            icon: 'üåà',
            name: 'Positive',
            presets: [
                "Calm & okay",
                "Felt supported",
                "Good energy",
                "Productive flow",
                "Rested / safe"
            ]
        },
        episode: {
            icon: '‚ö†Ô∏è',
            name: 'Episode',
            presets: [
                "Feels like an episode starting",
                "Episode ongoing"
            ]
        }
    };

    // Storage helpers
    function getData() {
        try {
            const data = localStorage.getItem('itsNotedData');
            return data ? JSON.parse(data) : {
                events: [],
                people: {
                    work: [],
                    friends: [],
                    relationship: []
                },
                customPresets: {},
                customCategories: {},
                activeEpisode: null
            };
        } catch (e) {
            console.error('Error reading data:', e);
            return {
                events: [],
                people: { work: [], friends: [], relationship: [] },
                customPresets: {},
                customCategories: {},
                activeEpisode: null
            };
        }
    }

    function saveData(data) {
        try {
            localStorage.setItem('itsNotedData', JSON.stringify(data));
        } catch (e) {
            console.error('Error saving data:', e);
            showToast('Error saving data');
        }
    }

    function saveEvent(eventData) {
        const data = getData();
        const event = {
            id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
            timestamp: new Date().toISOString(),
            date: new Date().toISOString().split('T')[0],
            timeOfDay: getTimeOfDay(),
            ...eventData
        };
        data.events.push(event);
        
        // Handle episode linking
        if (eventData.category === 'episode') {
            if (eventData.status === 'starting' || eventData.status === 'ongoing') {
                if (!data.activeEpisode) {
                    data.activeEpisode = {
                        startId: event.id,
                        events: [event.id]
                    };
                } else {
                    data.activeEpisode.events.push(event.id);
                }
            } else if (eventData.status === 'resolved') {
                data.activeEpisode = null;
            }
        }
        
        saveData(data);
        return event;
    }

    function getTimeOfDay() {
        const hour = new Date().getHours();
        if (hour < 12) return 'morning';
        if (hour < 17) return 'afternoon';
        if (hour < 21) return 'evening';
        return 'night';
    }

    // Toast notification
    function showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 2000);
    }

    // Navigation functions
    function showQuickLog() {
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('quickLogScreen').classList.remove('hidden');
        renderQuickLog();
    }

    function closeQuickLog() {
        document.getElementById('quickLogScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
    }

    function showManualLog() {
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('manualLogScreen').classList.remove('hidden');
        renderManualLogStart();
    }

    function closeManualLog() {
        document.getElementById('manualLogScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
    }

    function showMyData() {
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('myDataScreen').classList.remove('hidden');
        showDataView('insights');
    }

    function closeMyData() {
        document.getElementById('myDataScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
    }

    function showSettings() {
        document.getElementById('homeScreen').classList.add('hidden');
        document.getElementById('settingsScreen').classList.remove('hidden');
        renderSettings();
    }

    function closeSettings() {
        document.getElementById('settingsScreen').classList.add('hidden');
        document.getElementById('homeScreen').classList.remove('hidden');
    }

    // Quick Log rendering
    function renderQuickLog() {
        const container = document.getElementById('quickLogCategories');
        const data = getData();
        
        // Merge default presets with custom presets
        const allPresets = { ...DEFAULT_PRESETS };
        
        // Add custom presets to existing categories
        if (data.customPresets) {
            Object.entries(data.customPresets).forEach(([category, presets]) => {
                if (allPresets[category]) {
                    allPresets[category] = {
                        ...allPresets[category],
                        presets: [...allPresets[category].presets, ...presets]
                    };
                }
            });
        }
        
        // Add custom categories
        if (data.customCategories) {
            Object.entries(data.customCategories).forEach(([key, category]) => {
                allPresets[key] = {
                    icon: category.icon,
                    name: category.name,
                    presets: category.presets || []
                };
            });
        }
        
        container.innerHTML = Object.keys(allPresets).map(key => {
            const category = allPresets[key];
            if (!category.presets || category.presets.length === 0) return ''; // Skip empty categories
            
            return `
                <div class="preset-category">
                    <div class="category-header" data-category="${key}">
                        <div class="category-title">
                            <span class="category-icon">${category.icon}</span>
                            <span>${category.name}</span>
                        </div>
                        <span class="category-toggle">‚ñº</span>
                    </div>
                    <div class="presets" data-presets="${key}">
                        ${category.presets.map(preset => 
                            `<button class="preset-button" data-category="${key}" data-preset="${preset}">${preset}</button>`
                        ).join('')}
                    </div>
                </div>
            `;
        }).join('');

        // Add event listeners for category toggles
        container.querySelectorAll('.category-header').forEach(header => {
            header.addEventListener('click', function() {
                const category = this.dataset.category;
                const presets = container.querySelector(`[data-presets="${category}"]`);
                const toggle = this.querySelector('.category-toggle');
                presets.classList.toggle('open');
                toggle.classList.toggle('open');
            });
        });

        // Add event listeners for preset buttons
        container.querySelectorAll('.preset-button').forEach(btn => {
            btn.addEventListener('click', function() {
                logQuickPreset(this.dataset.category, this.dataset.preset);
            });
        });
    }

    function logQuickPreset(category, preset) {
        const isPositive = category === 'positive';
        const isEpisode = category === 'episode';
        
        const eventData = {
            category: category,
            preset: preset,
            isPositive: isPositive,
            isEpisode: isEpisode
        };
        
        if (isEpisode) {
            eventData.status = preset.includes('starting') ? 'starting' : 'ongoing';
        }
        
        saveEvent(eventData);
        showToast('Logged ‚úì');
    }

    // Manual Log flows
    function renderManualLogStart() {
        const flow = document.getElementById('manualLogFlow');
        const data = getData();
        
        let episodeOption = '';
        if (data.activeEpisode) {
            episodeOption = `
                <button class="option-button" data-action="episode-continue">
                    ‚ö†Ô∏è Continue Episode Log
                </button>
                <button class="option-button" data-action="episode-end">
                    ‚úì I'm Feeling Functional Again
                </button>
            `;
        }

        // Build custom category buttons
        let customCategoryButtons = '';
        if (data.customCategories) {
            customCategoryButtons = Object.entries(data.customCategories).map(([key, cat]) => 
                `<button class="option-button" data-action="${key}">${cat.icon} ${cat.name}</button>`
            ).join('');
        }
        
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What would you like to log?</div>
                <div class="flow-options">
                    ${episodeOption}
                    <button class="option-button" data-action="sleep">üí§ Sleep</button>
                    <button class="option-button" data-action="work">üè¢ Work</button>
                    <button class="option-button" data-action="friends">üë• Friends</button>
                    <button class="option-button" data-action="relationship">üíï Relationship</button>
                    <button class="option-button" data-action="internal">üß† Internal</button>
                    <button class="option-button" data-action="positive">üåà Positive</button>
                    <button class="option-button" data-action="episode">‚ö†Ô∏è Episode</button>
                    ${customCategoryButtons}
                </div>
            </div>
        `;

        // Add event listeners
        flow.querySelectorAll('.option-button').forEach(btn => {
            btn.addEventListener('click', function() {
                selectManualCategory(this.dataset.action);
            });
        });
    }

    function selectManualCategory(category) {
        App.manualLogState.category = category;
        App.manualLogState.data = { category: category };
        
        if (category === 'episode-end') {
            saveEvent({
                category: 'episode',
                status: 'resolved',
                isEpisode: true
            });
            showToast('Noted ‚Äî glad you\'re feeling better ‚úì');
            closeManualLog();
            return;
        }
        
        if (category === 'episode-continue') {
            renderEpisodeFlow(true);
            return;
        }
        
        // Check if this is a custom category
        const data = getData();
        const isCustomCategory = data.customCategories && data.customCategories[category];
        
        if (isCustomCategory) {
            // For custom categories, just save with basic info
            saveEvent({
                category: category,
                isPositive: false,
                isEpisode: false
            });
            showToast(`${data.customCategories[category].name} log saved ‚úì`);
            closeManualLog();
            return;
        }
        
        // Handle built-in categories with their specific flows
        switch(category) {
            case 'sleep': renderSleepFlow(); break;
            case 'work': renderWorkFlow(); break;
            case 'friends': renderFriendsFlow(); break;
            case 'relationship': renderRelationshipFlow(); break;
            case 'internal': renderInternalFlow(); break;
            case 'positive': renderPositiveFlow(); break;
            case 'episode': renderEpisodeFlow(false); break;
        }
    }

    function renderSleepFlow() {
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What's happening?</div>
                <div class="flow-options">
                    <button class="option-button" data-sleep="cant-fall-asleep">Can't fall asleep</button>
                    <button class="option-button" data-sleep="woke-up">Woke up & can't go back</button>
                    <button class="option-button" data-sleep="not-rested">Slept but not rested</button>
                    <button class="option-button" data-sleep="bad-streak">Bad sleep streak</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-sleep]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectSleepType(this.dataset.sleep);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectSleepType(type) {
        App.manualLogState.data.sleepType = type;
        App.manualLogState.data.reasons = [];
        
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Why? (select all that apply)</div>
                <div class="multi-select-grid" id="reasonsGrid">
                    <div class="multi-option" data-reason="racing-thoughts">Racing thoughts</div>
                    <div class="multi-option" data-reason="bad-thoughts">Bad thoughts</div>
                    <div class="multi-option" data-reason="anxiety">Anxiety</div>
                    <div class="multi-option" data-reason="not-tired">Not tired</div>
                    <div class="multi-option" data-reason="discomfort">Body discomfort</div>
                    <div class="multi-option" data-reason="unknown">Unknown</div>
                </div>
                <div class="flow-header">Intensity</div>
                <div class="slider-container">
                    <input type="range" min="1" max="100" value="50" class="slider" id="intensitySlider">
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToSleep">‚Üê Back</button>
                    <button class="button small" id="saveSleepBtn">Save Log</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('.multi-option').forEach(opt => {
            opt.addEventListener('click', function() {
                this.classList.toggle('selected');
                const reason = this.dataset.reason;
                const index = App.manualLogState.data.reasons.indexOf(reason);
                if (index > -1) {
                    App.manualLogState.data.reasons.splice(index, 1);
                } else {
                    App.manualLogState.data.reasons.push(reason);
                }
            });
        });

        flow.querySelector('#backToSleep').addEventListener('click', renderSleepFlow);
        flow.querySelector('#saveSleepBtn').addEventListener('click', saveSleepLog);
    }

    function saveSleepLog() {
        App.manualLogState.data.severity = document.getElementById('intensitySlider').value;
        saveEvent({
            category: 'sleep',
            subcategory: App.manualLogState.data.sleepType,
            reasons: App.manualLogState.data.reasons,
            severity: parseInt(App.manualLogState.data.severity),
            isPositive: false,
            isEpisode: false
        });
        showToast('Sleep log saved ‚úì');
        closeManualLog();
    }

    function renderWorkFlow() {
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What kind of work issue?</div>
                <div class="flow-options">
                    <button class="option-button" data-work="person">Person</button>
                    <button class="option-button" data-work="task">Task / workload</button>
                    <button class="option-button" data-work="meeting">Meeting</button>
                    <button class="option-button" data-work="deadline">Deadline</button>
                    <button class="option-button" data-work="general">General stress</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-work]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectWorkType(this.dataset.work);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectWorkType(type) {
        App.manualLogState.data.workType = type;
        if (type === 'person') {
            renderWorkPersonSelect();
        } else {
            saveWorkLog();
        }
    }

    function renderWorkPersonSelect() {
        const data = getData();
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Who?</div>
                <div class="flow-options">
                    ${data.people.work.map(person => 
                        `<button class="option-button" data-person="${person}">${person}</button>`
                    ).join('')}
                    ${data.people.work.length === 0 ? '<p style="color: var(--text-light); text-align: center;">No people added yet. Add them in Settings.</p>' : ''}
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToWork">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-person]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectWorkPerson(this.dataset.person);
            });
        });
        flow.querySelector('#backToWork').addEventListener('click', renderWorkFlow);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectWorkPerson(person) {
        App.manualLogState.data.person = person;
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What's happening?</div>
                <div class="flow-options">
                    <button class="option-button" data-situation="conflict">Conflict</button>
                    <button class="option-button" data-situation="anticipation">Anticipation</button>
                    <button class="option-button" data-situation="after-interaction">After interaction</button>
                    <button class="option-button" data-situation="ongoing-tension">Ongoing tension</button>
                    <button class="option-button" data-situation="unexpected">Unexpected contact</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToPerson">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-situation]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectWorkSituation(this.dataset.situation);
            });
        });
        flow.querySelector('#backToPerson').addEventListener('click', renderWorkPersonSelect);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectWorkSituation(situation) {
        App.manualLogState.data.situation = situation;
        App.manualLogState.data.reasons = App.manualLogState.data.reasons || [];
        
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Impact (select all that apply)</div>
                <div class="multi-select-grid">
                    <div class="multi-option" data-impact="anxiety">Anxiety</div>
                    <div class="multi-option" data-impact="irritability">Irritability</div>
                    <div class="multi-option" data-impact="drained">Drained</div>
                    <div class="multi-option" data-impact="overstimulated">Overstimulated</div>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToSituation">‚Üê Back</button>
                    <button class="button small" id="saveWorkBtn">Save Log</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('.multi-option').forEach(opt => {
            opt.addEventListener('click', function() {
                this.classList.toggle('selected');
                const impact = this.dataset.impact;
                const index = App.manualLogState.data.reasons.indexOf(impact);
                if (index > -1) {
                    App.manualLogState.data.reasons.splice(index, 1);
                } else {
                    App.manualLogState.data.reasons.push(impact);
                }
            });
        });

        flow.querySelector('#backToSituation').addEventListener('click', () => selectWorkPerson(App.manualLogState.data.person));
        flow.querySelector('#saveWorkBtn').addEventListener('click', saveWorkLog);
    }

    function saveWorkLog() {
        saveEvent({
            category: 'work',
            subcategory: App.manualLogState.data.workType,
            person: App.manualLogState.data.person,
            situation: App.manualLogState.data.situation,
            impact: App.manualLogState.data.reasons || [],
            isPositive: false,
            isEpisode: false
        });
        showToast('Work log saved ‚úì');
        closeManualLog();
    }

    function renderFriendsFlow() {
        const data = getData();
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Who?</div>
                <div class="flow-options">
                    ${data.people.friends.map(person => 
                        `<button class="option-button" data-friend="${person}">${person}</button>`
                    ).join('')}
                    ${data.people.friends.length === 0 ? '<p style="color: var(--text-light); text-align: center;">No friends added yet. Add them in Settings.</p>' : ''}
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-friend]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectFriend(this.dataset.friend);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectFriend(person) {
        App.manualLogState.data.person = person;
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What's happening?</div>
                <div class="flow-options">
                    <button class="option-button" data-friend-situation="conflict">Conflict</button>
                    <button class="option-button" data-friend-situation="excluded">Feeling excluded</button>
                    <button class="option-button" data-friend-situation="drained">Drained</button>
                    <button class="option-button" data-friend-situation="overstimulated">Overstimulated</button>
                    <button class="option-button" data-friend-situation="supported">Supported</button>
                    <button class="option-button" data-friend-situation="fun">Fun / connected</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToFriends">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-friend-situation]').forEach(btn => {
            btn.addEventListener('click', function() {
                saveFriendsLog(this.dataset.friendSituation);
            });
        });
        flow.querySelector('#backToFriends').addEventListener('click', renderFriendsFlow);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function saveFriendsLog(situation) {
        const isPositive = ['supported', 'fun'].includes(situation);
        saveEvent({
            category: 'friends',
            person: App.manualLogState.data.person,
            situation: situation,
            isPositive: isPositive,
            isEpisode: false
        });
        showToast('Friends log saved ‚úì');
        closeManualLog();
    }

    function renderRelationshipFlow() {
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What's happening?</div>
                <div class="flow-options">
                    <button class="option-button" data-rel="conflict">Conflict</button>
                    <button class="option-button" data-rel="distance">Distance</button>
                    <button class="option-button" data-rel="miscommunication">Miscommunication</button>
                    <button class="option-button" data-rel="supported">Feeling supported</button>
                    <button class="option-button" data-rel="secure">Feeling secure</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-rel]').forEach(btn => {
            btn.addEventListener('click', function() {
                saveRelationshipLog(this.dataset.rel);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function saveRelationshipLog(situation) {
        const isPositive = ['supported', 'secure'].includes(situation);
        saveEvent({
            category: 'relationship',
            situation: situation,
            isPositive: isPositive,
            isEpisode: false
        });
        showToast('Relationship log saved ‚úì');
        closeManualLog();
    }

    function renderInternalFlow() {
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What state fits?</div>
                <div class="flow-options">
                    <button class="option-button" data-internal="numb">Numb / disconnected</button>
                    <button class="option-button" data-internal="heavy">Heavy / low</button>
                    <button class="option-button" data-internal="anxious">Anxious</button>
                    <button class="option-button" data-internal="overstimulated">Overstimulated</button>
                    <button class="option-button" data-internal="burnt-out">Burnt out</button>
                    <button class="option-button" data-internal="irritable">Irritable</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-internal]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectInternalState(this.dataset.internal);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectInternalState(state) {
        App.manualLogState.data.state = state;
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Does this feel connected to something?</div>
                <div class="flow-options">
                    <button class="option-button" data-context="work">Work</button>
                    <button class="option-button" data-context="friends">Friends</button>
                    <button class="option-button" data-context="relationship">Relationship</button>
                    <button class="option-button" data-context="sleep">Sleep</button>
                    <button class="option-button" data-context="unknown">Unknown</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToInternal">‚Üê Back</button>
                    <button class="button small" id="saveInternalNoContext">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-context]').forEach(btn => {
            btn.addEventListener('click', function() {
                saveInternalLog(this.dataset.context);
            });
        });
        flow.querySelector('#backToInternal').addEventListener('click', renderInternalFlow);
        flow.querySelector('#saveInternalNoContext').addEventListener('click', () => saveInternalLog(null));
    }

    function saveInternalLog(context) {
        saveEvent({
            category: 'internal',
            state: App.manualLogState.data.state,
            context: context,
            isPositive: false,
            isEpisode: false
        });
        showToast('Internal log saved ‚úì');
        closeManualLog();
    }

    function renderPositiveFlow() {
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">What kind?</div>
                <div class="flow-options">
                    <button class="option-button" data-positive="calm">Calm</button>
                    <button class="option-button" data-positive="rested">Rested</button>
                    <button class="option-button" data-positive="supported">Supported</button>
                    <button class="option-button" data-positive="productive">Productive</button>
                    <button class="option-button" data-positive="fun">Fun</button>
                    <button class="option-button" data-positive="safe">Safe</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-positive]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectPositiveType(this.dataset.positive);
            });
        });
        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectPositiveType(type) {
        App.manualLogState.data.positiveType = type;
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Context</div>
                <div class="flow-options">
                    <button class="option-button" data-pos-context="work">Work</button>
                    <button class="option-button" data-pos-context="friends">Friends</button>
                    <button class="option-button" data-pos-context="home">Home</button>
                    <button class="option-button" data-pos-context="alone">Alone</button>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToPositive">‚Üê Back</button>
                    <button class="button small" id="savePartialBtn">Save As-Is</button>
                </div>
            </div>
        `;

        flow.querySelectorAll('[data-pos-context]').forEach(btn => {
            btn.addEventListener('click', function() {
                selectPositiveContext(this.dataset.posContext);
            });
        });
        flow.querySelector('#backToPositive').addEventListener('click', renderPositiveFlow);
        flow.querySelector('#savePartialBtn').addEventListener('click', promptSavePartial);
    }

    function selectPositiveContext(context) {
        App.manualLogState.data.context = context;
        const flow = document.getElementById('manualLogFlow');
        flow.innerHTML = `
            <div class="flow-screen">
                <div class="flow-header">Intensity</div>
                <div class="slider-container">
                    <input type="range" min="1" max="100" value="50" class="slider" id="intensitySlider">
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToContext">‚Üê Back</button>
                    <button class="button small" id="savePositiveBtn">Save Log</button>
                </div>
            </div>
        `;

        flow.querySelector('#backToContext').addEventListener('click', () => selectPositiveType(App.manualLogState.data.positiveType));
        flow.querySelector('#savePositiveBtn').addEventListener('click', savePositiveLog);
    }

    function savePositiveLog() {
        App.manualLogState.data.severity = document.getElementById('intensitySlider').value;
        saveEvent({
            category: 'positive',
            type: App.manualLogState.data.positiveType,
            context: App.manualLogState.data.context,
            severity: parseInt(App.manualLogState.data.severity),
            isPositive: true,
            isEpisode: false
        });
        showToast('Positive log saved ‚úì');
        closeManualLog();
    }

    function renderEpisodeFlow(continuing) {
        App.manualLogState.data.reasons = [];
        
        const flow = document.getElementById('manualLogFlow');
        const statusSection = continuing ? '' : `
            <div class="flow-header">Status</div>
            <div class="flow-options" id="episodeStatusOptions">
                <button class="option-button" data-episode-status="starting">Starting</button>
                <button class="option-button" data-episode-status="ongoing">Ongoing</button>
                <button class="option-button" data-episode-status="improving">Improving</button>
            </div>
        `;
        
        flow.innerHTML = `
            <div class="flow-screen">
                ${statusSection}
                <div class="flow-header">Severity</div>
                <div class="slider-container">
                    <input type="range" min="1" max="100" value="50" class="slider" id="severitySlider">
                </div>
                <div class="flow-header">Symptoms (select all that apply)</div>
                <div class="multi-select-grid" id="symptomsGrid">
                    <div class="multi-option" data-symptom="numb">Numb</div>
                    <div class="multi-option" data-symptom="hopeless">Hopeless</div>
                    <div class="multi-option" data-symptom="tearful">Tearful</div>
                    <div class="multi-option" data-symptom="irritable">Irritable</div>
                    <div class="multi-option" data-symptom="withdrawn">Withdrawn</div>
                </div>
                <div class="flow-header">Context</div>
                <div class="multi-select-grid" id="contextGrid">
                    <div class="multi-option" data-context="work-ctx">Work</div>
                    <div class="multi-option" data-context="friends-ctx">Friends</div>
                    <div class="multi-option" data-context="sleep-ctx">Sleep</div>
                    <div class="multi-option" data-context="unknown-ctx">Unknown</div>
                </div>
                <div class="flow-actions">
                    <button class="button small back-button" id="backToStart">‚Üê Back</button>
                    <button class="button small" id="saveEpisodeBtn">Save Log</button>
                </div>
            </div>
        `;

        if (!continuing) {
            flow.querySelectorAll('[data-episode-status]').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.add('selected');
                    App.manualLogState.data.episodeStatus = this.dataset.episodeStatus;
                    // Deselect others
                    flow.querySelectorAll('[data-episode-status]').forEach(b => {
                        if (b !== this) b.classList.remove('selected');
                    });
                });
            });
        }

        flow.querySelectorAll('[data-symptom], [data-context]').forEach(opt => {
            opt.addEventListener('click', function() {
                this.classList.toggle('selected');
                const value = this.dataset.symptom || this.dataset.context;
                const index = App.manualLogState.data.reasons.indexOf(value);
                if (index > -1) {
                    App.manualLogState.data.reasons.splice(index, 1);
                } else {
                    App.manualLogState.data.reasons.push(value);
                }
            });
        });

        flow.querySelector('#backToStart').addEventListener('click', renderManualLogStart);
        flow.querySelector('#saveEpisodeBtn').addEventListener('click', () => saveEpisodeLog(continuing ? 'ongoing' : null));
    }

    function saveEpisodeLog(defaultStatus) {
        const status = App.manualLogState.data.episodeStatus || defaultStatus;
        saveEvent({
            category: 'episode',
            status: status,
            severity: parseInt(document.getElementById('severitySlider').value),
            symptoms: App.manualLogState.data.reasons.filter(r => !r.includes('-ctx')),
            context: App.manualLogState.data.reasons.filter(r => r.includes('-ctx')).map(r => r.replace('-ctx', '')),
            isPositive: false,
            isEpisode: true
        });
        showToast('Episode log saved ‚úì');
        closeManualLog();
    }

    function promptSavePartial() {
        const modal = document.getElementById('modalContainer');
        modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal">
                    <h3>Save partial log?</h3>
                    <p>You can save what you've filled out so far, or continue adding details.</p>
                    <div class="modal-buttons">
                        <button class="button secondary" id="continueBtn">Continue</button>
                        <button class="button" id="saveAsIsBtn">Save As-Is</button>
                    </div>
                </div>
            </div>
        `;

        modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay')) {
                closeModal();
            }
        });
        modal.querySelector('#continueBtn').addEventListener('click', closeModal);
        modal.querySelector('#saveAsIsBtn').addEventListener('click', savePartialLog);
    }

    function savePartialLog() {
        saveEvent({
            ...App.manualLogState.data,
            partial: true,
            isPositive: false,
            isEpisode: false
        });
        showToast('Partial log saved ‚úì');
        closeModal();
        closeManualLog();
    }

    function closeModal() {
        document.getElementById('modalContainer').innerHTML = '';
    }

    // My Data views
    function showDataView(view) {
        document.querySelectorAll('.view-tab').forEach(tab => {
            tab.classList.remove('active');
            if (tab.dataset.view === view) {
                tab.classList.add('active');
            }
        });
        
        const content = document.getElementById('dataViewContent');
        const data = getData();
        
        switch(view) {
            case 'insights':
                renderInsights(content, data);
                break;
            case 'overview':
                renderOverview(content, data);
                break;
            case 'calendar':
                renderCalendar(content, data);
                break;
            case 'patterns':
                renderPatterns(content, data);
                break;
        }
    }

    function renderInsights(content, data) {
        if (data.events.length < 3) {
            content.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 40px 0;">Not enough logs yet. Keep tracking to surface insights.</p>';
            return;
        }

        const insights = InsightEngine.detect(data.events);
        
        if (insights.length === 0) {
            content.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 40px 0;">No clear patterns yet. Insights appear as patterns become more defined.</p>';
            return;
        }

        // Category emoji mapping
        const categoryEmojis = {
            'sleep': 'üí§',
            'work': 'üè¢',
            'internal': 'üß†',
            'social': 'üë•',
            'positive': 'üåà',
            'episode': '‚ö†Ô∏è',
            'friends': 'üë•',
            'relationship': 'üíï'
        };

        // Time of day emoji mapping
        const timeEmojis = {
            'morning': 'üåÖ',
            'afternoon': '‚òÄÔ∏è',
            'evening': 'üåÜ',
            'night': 'üåô'
        };

        let html = '<div style="margin-bottom: 16px; color: var(--text-light); font-size: 14px; line-height: 1.5;">These insights are automatically detected patterns in your logs. Tap any insight to see how it was calculated.</div>';
        
        insights.forEach((insight, index) => {
            let title = insight.title;
            
            // Replace category names with emoji + name for better visual consistency
            Object.entries(categoryEmojis).forEach(([category, emoji]) => {
                const regex = new RegExp(`\\b${category}\\b`, 'gi');
                title = title.replace(regex, `<span class="insight-emoji">${emoji}</span> ${category}`);
            });

            // Replace time-of-day text with emoji + text
            Object.entries(timeEmojis).forEach(([time, emoji]) => {
                const regex = new RegExp(`\\bin the ${time}\\b`, 'gi');
                title = title.replace(regex, `in the <span class="insight-emoji">${emoji}</span> ${time}`);
            });
            
            html += `
                <div class="pattern-item" style="cursor: pointer; transition: transform 0.2s;" data-insight-index="${index}">
                    <div class="pattern-title">${title}</div>
                    <div class="pattern-detail">${insight.detail}</div>
                </div>
            `;
        });
        
        content.innerHTML = html;

        // Add click handlers to show explanations
        content.querySelectorAll('.pattern-item').forEach((item, index) => {
            item.addEventListener('click', function() {
                showInsightExplanation(insights[index]);
            });
        });
    }

    function showInsightExplanation(insight) {
        const modal = document.getElementById('modalContainer');
        modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal">
                    <h3>${insight.title}</h3>
                    <p style="color: var(--text-light); line-height: 1.6; margin-top: 12px;">
                        ${insight.explanation}
                    </p>
                    <div class="modal-buttons">
                        <button class="button" id="closeExplanation">Got it</button>
                    </div>
                </div>
            </div>
        `;

        modal.querySelector('.modal-overlay').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay')) {
                closeModal();
            }
        });
        modal.querySelector('#closeExplanation').addEventListener('click', closeModal);
    }

    function renderOverview(content, data) {
        if (data.events.length === 0) {
            content.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 40px 0;">No logs yet. Start tracking to see patterns emerge.</p>';
            return;
        }

        // Find sequences (what follows what)
        const sequences = findSequences(data.events);
        
        // Find co-occurrences (same day combinations)
        const cooccurrences = findCooccurrences(data.events);
        
        // Find time-of-day patterns
        const timePatterns = findTimePatterns(data.events);
        
        let html = '<div class="export-section" style="margin-bottom: 24px;"><button class="button secondary small" id="exportBtn">Export All Data</button></div>';
        
        // Sequences section
        if (sequences.length > 0) {
            html += '<h3 style="margin: 24px 0 12px; color: var(--primary);">What Often Follows</h3>';
            sequences.slice(0, 4).forEach(seq => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${seq.first} ‚Üí ${seq.second}</div>
                        <div class="pattern-detail">${seq.count} time${seq.count > 1 ? 's' : ''} within same day</div>
                    </div>
                `;
            });
        }
        
        // Co-occurrences section
        if (cooccurrences.length > 0) {
            html += '<h3 style="margin: 24px 0 12px; color: var(--primary);">What Shows Up Together</h3>';
            cooccurrences.slice(0, 4).forEach(co => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${co.category1} + ${co.category2}</div>
                        <div class="pattern-detail">${co.count} day${co.count > 1 ? 's' : ''} with both</div>
                    </div>
                `;
            });
        }
        
        // Time patterns section
        if (timePatterns.length > 0) {
            html += '<h3 style="margin: 24px 0 12px; color: var(--primary);">Time Patterns</h3>';
            timePatterns.slice(0, 3).forEach(pattern => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${pattern.category} in the ${pattern.time}</div>
                        <div class="pattern-detail">${pattern.percentage}% of ${pattern.category} logs</div>
                    </div>
                `;
            });
        }
        
        content.innerHTML = html;

        const exportBtn = content.querySelector('#exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', exportData);
        }
    }

    // ========================================
    // V2 INSIGHT ENGINE
    // Deterministic rules for pattern detection
    // No AI, no recommendations, just observations
    // ========================================

    const InsightEngine = {
        // Detect all insights from event data
        detect: function(events) {
            if (events.length < 3) return [];
            
            const insights = [];
            
            // Run all detection rules
            insights.push(...this.detectRepetition(events));
            insights.push(...this.detectCooccurrence(events));
            insights.push(...this.detectSequence(events));
            insights.push(...this.detectEpisodeProximity(events));
            insights.push(...this.detectSimilarity(events));
            insights.push(...this.detectTimeWindows(events));
            insights.push(...this.detectStreaks(events));
            
            // Sort by strength (how often the pattern appears)
            return insights.sort((a, b) => b.strength - a.strength);
        },

        // Rule: Same category appearing multiple times in short periods
        detectRepetition: function(events) {
            const insights = [];
            const categoryCounts = {};
            
            // Count occurrences per category
            events.forEach(e => {
                categoryCounts[e.category] = (categoryCounts[e.category] || 0) + 1;
            });
            
            // Find categories that repeat frequently (>20% of logs)
            const totalLogs = events.length;
            Object.entries(categoryCounts).forEach(([category, count]) => {
                const percentage = (count / totalLogs) * 100;
                if (percentage >= 20 && count >= 4) {
                    insights.push({
                        type: 'repetition',
                        title: `${category} shows up regularly`,
                        detail: `${count} times (${Math.round(percentage)}% of logs)`,
                        strength: count,
                        explanation: `This category has been logged ${count} times out of ${totalLogs} total logs.`
                    });
                }
            });
            
            return insights;
        },

        // Rule: Two categories appearing on the same days
        detectCooccurrence: function(events) {
            const insights = [];
            const dayCategories = {};
            
            // Group categories by day
            events.forEach(e => {
                if (!dayCategories[e.date]) {
                    dayCategories[e.date] = new Set();
                }
                dayCategories[e.date].add(e.category);
            });
            
            // Find category pairs that co-occur
            const pairs = {};
            Object.values(dayCategories).forEach(categories => {
                const cats = Array.from(categories);
                for (let i = 0; i < cats.length; i++) {
                    for (let j = i + 1; j < cats.length; j++) {
                        const key = [cats[i], cats[j]].sort().join('|');
                        pairs[key] = (pairs[key] || 0) + 1;
                    }
                }
            });
            
            // Surface pairs that appear together frequently (3+ times)
            Object.entries(pairs).forEach(([key, count]) => {
                if (count >= 3) {
                    const [cat1, cat2] = key.split('|');
                    insights.push({
                        type: 'cooccurrence',
                        title: `${cat1} and ${cat2} often show up together`,
                        detail: `Same day ${count} times`,
                        strength: count,
                        explanation: `These two categories have appeared on the same day ${count} times.`
                    });
                }
            });
            
            return insights;
        },

        // Rule: One category consistently followed by another
        detectSequence: function(events) {
            const insights = [];
            const sorted = [...events].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const sequences = {};
            
            // Track what follows what (within 6 hours)
            for (let i = 0; i < sorted.length - 1; i++) {
                const current = sorted[i];
                const next = sorted[i + 1];
                
                const timeDiff = new Date(next.timestamp) - new Date(current.timestamp);
                const hoursDiff = timeDiff / (1000 * 60 * 60);
                
                // Within same day and within 6 hours
                if (current.date === next.date && hoursDiff <= 6 && current.category !== next.category) {
                    const key = `${current.category}‚Üí${next.category}`;
                    sequences[key] = (sequences[key] || 0) + 1;
                }
            }
            
            // Surface sequences that happen repeatedly (3+ times)
            Object.entries(sequences).forEach(([key, count]) => {
                if (count >= 3) {
                    const [first, second] = key.split('‚Üí');
                    insights.push({
                        type: 'sequence',
                        title: `${second} tends to follow ${first}`,
                        detail: `${count} times within hours`,
                        strength: count,
                        explanation: `After logging ${first}, ${second} was logged within 6 hours on ${count} occasions.`
                    });
                }
            });
            
            return insights;
        },

        // Rule: Categories that appear before episodes
        detectEpisodeProximity: function(events) {
            const insights = [];
            const episodeEvents = events.filter(e => e.isEpisode || e.category === 'episode');
            
            if (episodeEvents.length < 2) return insights;
            
            const precursors = {};
            
            episodeEvents.forEach(episode => {
                const episodeDate = new Date(episode.date);
                
                // Look 3 days before episode
                const priorEvents = events.filter(e => {
                    const eventDate = new Date(e.date);
                    const daysDiff = Math.floor((episodeDate - eventDate) / (1000 * 60 * 60 * 24));
                    return daysDiff > 0 && daysDiff <= 3 && !e.isEpisode && e.category !== 'episode';
                });
                
                priorEvents.forEach(e => {
                    precursors[e.category] = (precursors[e.category] || 0) + 1;
                });
            });
            
            // Surface categories that appeared before multiple episodes
            Object.entries(precursors).forEach(([category, count]) => {
                if (count >= 2) {
                    insights.push({
                        type: 'episode-proximity',
                        title: `${category} appeared before episodes`,
                        detail: `${count} times in the 3 days prior`,
                        strength: count,
                        explanation: `${category} was logged in the 3 days before ${count} different episodes.`
                    });
                }
            });
            
            return insights;
        },

        // Rule: Days that have identical category combinations
        detectSimilarity: function(events) {
            const insights = [];
            const daySignatures = {};
            
            // Create signatures for each day
            events.forEach(e => {
                if (!daySignatures[e.date]) {
                    daySignatures[e.date] = new Set();
                }
                daySignatures[e.date].add(e.category);
            });
            
            // Group days by signature
            const signatureGroups = {};
            Object.entries(daySignatures).forEach(([date, categories]) => {
                const sig = Array.from(categories).sort().join('+');
                if (!signatureGroups[sig]) {
                    signatureGroups[sig] = [];
                }
                signatureGroups[sig].push(date);
            });
            
            // Surface signatures that repeat (3+ identical days, 2+ categories)
            Object.entries(signatureGroups).forEach(([sig, dates]) => {
                const categories = sig.split('+');
                if (dates.length >= 3 && categories.length >= 2) {
                    insights.push({
                        type: 'similarity',
                        title: `${categories.join(' + ')} pattern repeats`,
                        detail: `${dates.length} days look identical`,
                        strength: dates.length,
                        explanation: `This exact combination of categories appeared together on ${dates.length} different days.`
                    });
                }
            });
            
            return insights;
        },

        // Rule: Categories that cluster in specific times of day
        detectTimeWindows: function(events) {
            const insights = [];
            const categoryTimes = {};
            
            events.forEach(e => {
                if (!categoryTimes[e.category]) {
                    categoryTimes[e.category] = { morning: 0, afternoon: 0, evening: 0, night: 0, total: 0 };
                }
                categoryTimes[e.category][e.timeOfDay]++;
                categoryTimes[e.category].total++;
            });
            
            // Find strong time preferences (>60% in one window, 5+ logs)
            Object.entries(categoryTimes).forEach(([category, times]) => {
                if (times.total < 5) return;
                
                ['morning', 'afternoon', 'evening', 'night'].forEach(window => {
                    const percentage = (times[window] / times.total) * 100;
                    if (percentage >= 60) {
                        insights.push({
                            type: 'time-window',
                            title: `${category} tends to be in the ${window}`,
                            detail: `${Math.round(percentage)}% of ${category} logs`,
                            strength: times[window],
                            explanation: `Out of ${times.total} ${category} logs, ${times[window]} happened in the ${window}.`
                        });
                    }
                });
            });
            
            return insights;
        },

        // Rule: Consecutive days with the same category
        detectStreaks: function(events) {
            const insights = [];
            const sorted = [...events].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let currentStreak = { category: null, dates: [], count: 0 };
            const streaks = {};
            
            sorted.forEach(e => {
                const date = e.date;
                
                if (e.category === currentStreak.category) {
                    // Check if consecutive day
                    const lastDate = currentStreak.dates[currentStreak.dates.length - 1];
                    if (lastDate) {
                        const dayDiff = (new Date(date) - new Date(lastDate)) / (1000 * 60 * 60 * 24);
                        if (dayDiff === 1) {
                            currentStreak.dates.push(date);
                            currentStreak.count++;
                        } else {
                            // Streak broken, record it
                            if (currentStreak.count >= 3) {
                                streaks[currentStreak.category] = Math.max(
                                    streaks[currentStreak.category] || 0,
                                    currentStreak.count
                                );
                            }
                            currentStreak = { category: e.category, dates: [date], count: 1 };
                        }
                    } else {
                        currentStreak.dates.push(date);
                        currentStreak.count++;
                    }
                } else {
                    // Different category, record previous streak
                    if (currentStreak.count >= 3) {
                        streaks[currentStreak.category] = Math.max(
                            streaks[currentStreak.category] || 0,
                            currentStreak.count
                        );
                    }
                    currentStreak = { category: e.category, dates: [date], count: 1 };
                }
            });
            
            // Check final streak
            if (currentStreak.count >= 3) {
                streaks[currentStreak.category] = Math.max(
                    streaks[currentStreak.category] || 0,
                    currentStreak.count
                );
            }
            
            // Surface meaningful streaks
            Object.entries(streaks).forEach(([category, days]) => {
                insights.push({
                    type: 'streak',
                    title: `${category} happened ${days} days in a row`,
                    detail: `Longest consecutive streak`,
                    strength: days,
                    explanation: `The longest run of consecutive days with ${category} logs was ${days} days.`
                });
            });
            
            return insights;
        }
    };

    function findSequences(events) {
        // Sort events by timestamp
        const sorted = [...events].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const sequences = {};
        
        // Look at events within the same day
        for (let i = 0; i < sorted.length - 1; i++) {
            const current = sorted[i];
            const next = sorted[i + 1];
            
            // If same day, track sequence
            if (current.date === next.date && current.category !== next.category) {
                const key = `${current.category}‚Üí${next.category}`;
                sequences[key] = (sequences[key] || 0) + 1;
            }
        }
        
        return Object.entries(sequences)
            .map(([key, count]) => {
                const [first, second] = key.split('‚Üí');
                return { first, second, count };
            })
            .filter(s => s.count >= 2) // Only show if happened at least twice
            .sort((a, b) => b.count - a.count);
    }

    function findCooccurrences(events) {
        // Group events by date
        const eventsByDate = {};
        events.forEach(event => {
            if (!eventsByDate[event.date]) {
                eventsByDate[event.date] = [];
            }
            eventsByDate[event.date].push(event.category);
        });
        
        const pairs = {};
        
        // Find category pairs that appear on same days
        Object.values(eventsByDate).forEach(categories => {
            const unique = [...new Set(categories)];
            for (let i = 0; i < unique.length; i++) {
                for (let j = i + 1; j < unique.length; j++) {
                    const key = [unique[i], unique[j]].sort().join('+');
                    pairs[key] = (pairs[key] || 0) + 1;
                }
            }
        });
        
        return Object.entries(pairs)
            .map(([key, count]) => {
                const [category1, category2] = key.split('+');
                return { category1, category2, count };
            })
            .filter(p => p.count >= 2) // Only show if happened at least twice
            .sort((a, b) => b.count - a.count);
    }

    function findTimePatterns(events) {
        // Count categories by time of day
        const categoryTimeCount = {};
        
        events.forEach(event => {
            const cat = event.category;
            if (!categoryTimeCount[cat]) {
                categoryTimeCount[cat] = { morning: 0, afternoon: 0, evening: 0, night: 0, total: 0 };
            }
            categoryTimeCount[cat][event.timeOfDay]++;
            categoryTimeCount[cat].total++;
        });
        
        const patterns = [];
        
        // Find dominant time patterns (>40% in one time period)
        Object.entries(categoryTimeCount).forEach(([category, times]) => {
            if (times.total < 3) return; // Need at least 3 logs to find pattern
            
            ['morning', 'afternoon', 'evening', 'night'].forEach(time => {
                const percentage = Math.round((times[time] / times.total) * 100);
                if (percentage >= 40) {
                    patterns.push({ category, time, percentage });
                }
            });
        });
        
        return patterns.sort((a, b) => b.percentage - a.percentage);
    }

    function renderCalendar(content, data) {
        const today = new Date();
        const year = today.getFullYear();
        const month = today.getMonth();
        
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        const startingDayOfWeek = firstDay.getDay();
        
        const eventsByDate = {};
        data.events.forEach(event => {
            if (!eventsByDate[event.date]) {
                eventsByDate[event.date] = [];
            }
            eventsByDate[event.date].push(event);
        });
        
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                          'July', 'August', 'September', 'October', 'November', 'December'];
        
        let calendarHTML = `
            <h3 style="margin-bottom: 16px; color: var(--primary);">${monthNames[month]} ${year}</h3>
            <div class="calendar-grid">
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Su</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Mo</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Tu</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">We</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Th</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Fr</div>
                <div style="text-align: center; font-size: 12px; color: var(--text-light);">Sa</div>
        `;
        
        for (let i = 0; i < startingDayOfWeek; i++) {
            calendarHTML += '<div></div>';
        }
        
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const events = eventsByDate[dateStr] || [];
            const hasLogs = events.length > 0;
            
            calendarHTML += `
                <div class="calendar-day ${hasLogs ? 'has-logs' : ''}">
                    <div>${day}</div>
                    ${hasLogs ? `<div class="day-dots">${events.slice(0, 3).map(() => '<div class="day-dot"></div>').join('')}</div>` : ''}
                </div>
            `;
        }
        
        calendarHTML += '</div>';
        content.innerHTML = calendarHTML;
    }

    function renderPatterns(content, data) {
        if (data.events.length === 0) {
            content.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 40px 0;">No logs yet. Start tracking to see patterns emerge.</p>';
            return;
        }

        // Find similar days (days with same category combinations)
        const similarDays = findSimilarDays(data.events);
        
        // Find week-over-week patterns
        const weekPatterns = findWeekPatterns(data.events);
        
        // Find before-episode patterns
        const episodePatterns = findEpisodePatterns(data.events);
        
        let html = '';
        
        // Similar days section
        if (similarDays.length > 0) {
            html += '<h3 style="margin-bottom: 16px; color: var(--primary);">Days That Look Similar</h3>';
            similarDays.slice(0, 3).forEach(pattern => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${pattern.categories.join(' + ')}</div>
                        <div class="pattern-detail">${pattern.dates.length} days with this combination</div>
                    </div>
                `;
            });
        }
        
        // Week patterns section
        if (weekPatterns.length > 0) {
            html += '<h3 style="margin: 24px 0 16px; color: var(--primary);">Week Patterns</h3>';
            weekPatterns.slice(0, 3).forEach(pattern => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${pattern.description}</div>
                        <div class="pattern-detail">${pattern.weeks.length} weeks showed this</div>
                    </div>
                `;
            });
        }
        
        // Before-episode patterns
        if (episodePatterns.length > 0) {
            html += '<h3 style="margin: 24px 0 16px; color: var(--primary);">Before Episodes</h3>';
            episodePatterns.slice(0, 3).forEach(pattern => {
                html += `
                    <div class="pattern-item">
                        <div class="pattern-title">${pattern.category} appeared</div>
                        <div class="pattern-detail">In the ${pattern.daysRange} before ${pattern.count} episode${pattern.count > 1 ? 's' : ''}</div>
                    </div>
                `;
            });
        }
        
        // If no patterns found, show observation-based message
        if (html === '') {
            html = '<p style="color: var(--text-light); text-align: center; padding: 40px 0;">Not enough data yet to find recurring patterns. Keep logging.</p>';
        }
        
        content.innerHTML = html;
    }

    function findSimilarDays(events) {
        // Group events by date and get unique category combinations
        const dayPatterns = {};
        
        events.forEach(event => {
            if (!dayPatterns[event.date]) {
                dayPatterns[event.date] = new Set();
            }
            dayPatterns[event.date].add(event.category);
        });
        
        // Convert sets to sorted arrays for comparison
        const daySignatures = {};
        Object.entries(dayPatterns).forEach(([date, categories]) => {
            const signature = Array.from(categories).sort().join('+');
            if (!daySignatures[signature]) {
                daySignatures[signature] = [];
            }
            daySignatures[signature].push(date);
        });
        
        // Return patterns that happened on multiple days
        return Object.entries(daySignatures)
            .map(([signature, dates]) => ({
                categories: signature.split('+'),
                dates: dates
            }))
            .filter(p => p.dates.length >= 2 && p.categories.length >= 2)
            .sort((a, b) => b.dates.length - a.dates.length);
    }

    function findWeekPatterns(events) {
        // Group events by week
        const weekData = {};
        
        events.forEach(event => {
            const date = new Date(event.date);
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
            const weekKey = weekStart.toISOString().split('T')[0];
            
            if (!weekData[weekKey]) {
                weekData[weekKey] = { categories: new Set(), count: 0 };
            }
            weekData[weekKey].categories.add(event.category);
            weekData[weekKey].count++;
        });
        
        // Find recurring week patterns
        const patterns = {};
        
        Object.entries(weekData).forEach(([week, data]) => {
            // Pattern: high activity weeks (7+ logs)
            if (data.count >= 7) {
                if (!patterns['high-activity']) {
                    patterns['high-activity'] = { description: 'High activity (7+ logs)', weeks: [] };
                }
                patterns['high-activity'].weeks.push(week);
            }
            
            // Pattern: single-category weeks
            if (data.categories.size === 1) {
                const cat = Array.from(data.categories)[0];
                const key = `single-${cat}`;
                if (!patterns[key]) {
                    patterns[key] = { description: `Only ${cat} logged`, weeks: [] };
                }
                patterns[key].weeks.push(week);
            }
            
            // Pattern: multiple categories present
            if (data.categories.size >= 4) {
                if (!patterns['varied']) {
                    patterns['varied'] = { description: 'Varied logs (4+ categories)', weeks: [] };
                }
                patterns['varied'].weeks.push(week);
            }
        });
        
        return Object.values(patterns)
            .filter(p => p.weeks.length >= 2)
            .sort((a, b) => b.weeks.length - a.weeks.length);
    }

    function findEpisodePatterns(events) {
        // Find episode events
        const episodeEvents = events.filter(e => e.isEpisode || e.category === 'episode');
        
        if (episodeEvents.length === 0) {
            return [];
        }
        
        const patterns = {};
        
        episodeEvents.forEach(episode => {
            const episodeDate = new Date(episode.date);
            
            // Look at events in the 7 days before
            const priorEvents = events.filter(e => {
                const eventDate = new Date(e.date);
                const daysDiff = Math.floor((episodeDate - eventDate) / (1000 * 60 * 60 * 24));
                return daysDiff > 0 && daysDiff <= 7 && !e.isEpisode;
            });
            
            // Count categories that appeared before
            priorEvents.forEach(e => {
                const key = e.category;
                if (!patterns[key]) {
                    patterns[key] = { category: key, count: 0 };
                }
                patterns[key].count++;
            });
        });
        
        return Object.values(patterns)
            .filter(p => p.count >= 2) // Appeared before at least 2 episodes
            .map(p => ({
                ...p,
                daysRange: '1-7 days'
            }))
            .sort((a, b) => b.count - a.count);
    }

    function exportData() {
        const data = getData();
        const dataStr = JSON.stringify(data, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `its-noted-export-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        showToast('Data exported ‚úì');
    }

    // Settings
    function renderSettings() {
        const data = getData();
        const content = document.getElementById('settingsContent');
        
        content.innerHTML = `
            <div class="settings-section">
                <h3>Work People</h3>
                <div class="input-group">
                    <input type="text" id="workPersonInput" placeholder="Add person...">
                    <button class="button small" id="addWorkPersonBtn">Add</button>
                </div>
                <div class="person-list" id="workPeopleList">
                    ${data.people.work.map((person, i) => `
                        <div class="person-item">
                            <span>${person}</span>
                            <button class="delete-button" data-delete-work="${i}">Delete</button>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Friends</h3>
                <div class="input-group">
                    <input type="text" id="friendInput" placeholder="Add friend...">
                    <button class="button small" id="addFriendBtn">Add</button>
                </div>
                <div class="person-list" id="friendsList">
                    ${data.people.friends.map((person, i) => `
                        <div class="person-item">
                            <span>${person}</span>
                            <button class="delete-button" data-delete-friend="${i}">Delete</button>
                        </div>
                    `).join('')}
                </div>
            </div>

            <div class="settings-section">
                <h3>Custom Quick Log Presets</h3>
                <p>Add your own quick-log buttons.</p>
                <div class="input-group">
                    <select id="customPresetCategory" style="flex: 0.4;">
                        <option value="sleep">üí§ Sleep</option>
                        <option value="work">üè¢ Work</option>
                        <option value="internal">üß† Internal</option>
                        <option value="social">üë• Social</option>
                        <option value="positive">üåà Positive</option>
                    </select>
                    <input type="text" id="customPresetInput" placeholder="e.g., Nightmare" style="flex: 1;">
                </div>
                <button class="button small" id="addCustomPresetBtn" style="width: 100%; margin-bottom: 8px;">Add Preset</button>
                <div class="person-list" id="customPresetsList">
                    ${Object.entries(data.customPresets || {}).flatMap(([category, presets]) => 
                        presets.map((preset, i) => `
                            <div class="person-item">
                                <span>${DEFAULT_PRESETS[category]?.icon || '‚Ä¢'} ${preset}</span>
                                <button class="delete-button" data-delete-preset="${category}-${i}">Delete</button>
                            </div>
                        `)
                    ).join('') || '<p style="color: var(--text-light); text-align: center; padding: 8px 0; font-size: 13px;">None yet</p>'}
                </div>
            </div>

            <div class="settings-section">
                <h3>Custom Categories</h3>
                <p>Create new categories beyond defaults.</p>
                <div class="input-group">
                    <input type="text" id="customCategoryInput" placeholder="Name" style="flex: 0.6;">
                    <input type="text" id="customCategoryEmoji" placeholder="Emoji" maxlength="2" style="flex: 0.4; text-align: center;">
                </div>
                <button class="button small" id="addCustomCategoryBtn" style="width: 100%; margin-bottom: 8px;">Add Category</button>
                <div class="person-list" id="customCategoriesList">
                    ${Object.entries(data.customCategories || {}).map(([key, cat]) => `
                        <div class="person-item">
                            <span>${cat.icon} ${cat.name}</span>
                            <button class="delete-button" data-delete-category="${key}">Delete</button>
                        </div>
                    `).join('') || '<p style="color: var(--text-light); text-align: center; padding: 8px 0; font-size: 13px;">None yet</p>'}
                </div>
            </div>
            
            <div class="settings-section">
                <h3>About</h3>
                <p>
                    It's Noted is a private, judgment-free space for tracking patterns without explanation.
                    All data stays on your device. Nothing is shared.
                </p>
            </div>
        `;

        content.querySelector('#addWorkPersonBtn').addEventListener('click', () => addPerson('work'));
        content.querySelector('#addFriendBtn').addEventListener('click', () => addPerson('friends'));
        content.querySelector('#addCustomPresetBtn').addEventListener('click', addCustomPreset);
        content.querySelector('#addCustomCategoryBtn').addEventListener('click', addCustomCategory);
        
        content.querySelectorAll('[data-delete-work]').forEach(btn => {
            btn.addEventListener('click', function() {
                deletePerson('work', parseInt(this.dataset.deleteWork));
            });
        });
        
        content.querySelectorAll('[data-delete-friend]').forEach(btn => {
            btn.addEventListener('click', function() {
                deletePerson('friends', parseInt(this.dataset.deleteFriend));
            });
        });

        content.querySelectorAll('[data-delete-preset]').forEach(btn => {
            btn.addEventListener('click', function() {
                deleteCustomPreset(this.dataset.deletePreset);
            });
        });

        content.querySelectorAll('[data-delete-category]').forEach(btn => {
            btn.addEventListener('click', function() {
                deleteCustomCategory(this.dataset.deleteCategory);
            });
        });
    }

    function addCustomPreset() {
        const category = document.getElementById('customPresetCategory').value;
        const presetText = document.getElementById('customPresetInput').value.trim();
        
        if (!presetText) return;
        
        const data = getData();
        if (!data.customPresets) data.customPresets = {};
        if (!data.customPresets[category]) data.customPresets[category] = [];
        
        data.customPresets[category].push(presetText);
        saveData(data);
        renderSettings();
        showToast('Custom preset added ‚úì');
    }

    function deleteCustomPreset(key) {
        const [category, indexStr] = key.split('-');
        const index = parseInt(indexStr);
        
        const data = getData();
        if (data.customPresets && data.customPresets[category]) {
            data.customPresets[category].splice(index, 1);
            if (data.customPresets[category].length === 0) {
                delete data.customPresets[category];
            }
            saveData(data);
            renderSettings();
            showToast('Preset removed ‚úì');
        }
    }

    function addCustomCategory() {
        const name = document.getElementById('customCategoryInput').value.trim();
        const emoji = document.getElementById('customCategoryEmoji').value.trim();
        
        if (!name || !emoji) {
            showToast('Please enter both name and emoji');
            return;
        }
        
        const data = getData();
        if (!data.customCategories) data.customCategories = {};
        
        const key = name.toLowerCase().replace(/\s+/g, '-');
        data.customCategories[key] = {
            name: name,
            icon: emoji,
            presets: []
        };
        
        saveData(data);
        renderSettings();
        showToast('Custom category added ‚úì');
    }

    function deleteCustomCategory(key) {
        const data = getData();
        if (data.customCategories) {
            delete data.customCategories[key];
            saveData(data);
            renderSettings();
            showToast('Category removed ‚úì');
        }
    }

    function addPerson(type) {
        const inputId = type === 'work' ? 'workPersonInput' : 'friendInput';
        const input = document.getElementById(inputId);
        const name = input.value.trim();
        
        if (!name) return;
        
        const data = getData();
        if (!data.people[type].includes(name)) {
            data.people[type].push(name);
            saveData(data);
            renderSettings();
            showToast('Person added ‚úì');
        }
    }

    function deletePerson(type, index) {
        const data = getData();
        data.people[type].splice(index, 1);
        saveData(data);
        renderSettings();
        showToast('Person removed ‚úì');
    }

    // Initialize app on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('App initializing...');
        
        // Initialize data structure if needed
        const data = getData();
        if (!data.events) {
            saveData({
                events: [],
                people: { work: [], friends: [], relationship: [] },
                customPresets: {},
                customCategories: {},
                activeEpisode: null
            });
        }

        // Set up main navigation
        document.getElementById('quickLogBtn').addEventListener('click', showQuickLog);
        document.getElementById('manualLogBtn').addEventListener('click', showManualLog);
        document.getElementById('myDataBtn').addEventListener('click', showMyData);
        document.getElementById('settingsBtn').addEventListener('click', showSettings);

        // Set up close buttons
        document.getElementById('closeQuickLogBtn').addEventListener('click', closeQuickLog);
        document.getElementById('closeManualLogBtn').addEventListener('click', closeManualLog);
        document.getElementById('closeMyDataBtn').addEventListener('click', closeMyData);
        document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);

        // Set up My Data view tabs
        document.querySelectorAll('.view-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                showDataView(this.dataset.view);
            });
        });

        console.log('App initialized successfully!');
    });
</script>
<script>
    // Graceful error handling for logger
    window.addEventListener('error', function(e) {
        if (e.filename && e.filename.includes('logger.js')) {
            console.log('Logger not loaded - continuing without analytics');
            e.preventDefault();
        }
    });
</script>
<script src="logger.js"></script>
```

</body>
</html>
